function p(){}function q(t){return t&&typeof t=="object"&&typeof t.then=="function"}function w(t){return t()}function g(){return Object.create(null)}function y(t){t.forEach(w)}function C(t,n){return t!=t?n==n:t!==n||t&&typeof t=="object"||typeof t=="function"}function E(t,...n){if(t==null)return p;const e=t.subscribe(...n);return e.unsubscribe?()=>e.unsubscribe():e}function O(t){let n;return E(t,e=>n=e)(),n}function R(t,n,e){return t.set(e),n}const m=typeof window<"u";let T=m?()=>window.performance.now():()=>Date.now(),_=m?t=>requestAnimationFrame(t):p;const u=new Set;function $(t){u.forEach(n=>{n.c(t)||(u.delete(n),n.f())}),u.size!==0&&_($)}function z(t){let n;return u.size===0&&_($),{promise:new Promise(e=>{u.add(n={c:t,f:e})}),abort(){u.delete(n)}}}function v(t,n,{bubbles:e=!1,cancelable:o=!1}={}){const r=document.createEvent("CustomEvent");return r.initCustomEvent(t,e,o,n),r}let a;function d(t){a=t}function f(){if(!a)throw new Error("Function called outside component initialization");return a}function A(t){f().$$.on_destroy.push(t)}function D(){const t=f();return(n,e,{cancelable:o=!1}={})=>{const r=t.$$.callbacks[n];if(r){const s=v(n,e,{cancelable:o});return r.slice().forEach(c=>{c.call(t,s)}),!s.defaultPrevented}return!0}}function P(t,n){return f().$$.context.set(t,n),n}Promise.resolve();function F(t,n){const e={};for(const o of t.split(";")){const r=o.indexOf(":"),s=o.slice(0,r).trim(),c=o.slice(r+1).trim();!s||(e[s]=c)}for(const o in n){const r=n[o];r?e[o]=r:delete e[o]}return e}const j=/[&"]/g,x=/[&<]/g;function k(t,n=!1){const e=String(t),o=n?j:x;o.lastIndex=0;let r="",s=0;for(;o.test(e);){const c=o.lastIndex-1,i=e[c];r+=e.substring(s,c)+(i==="&"?"&amp;":i==='"'?"&quot;":"&lt;"),s=c+1}return r+e.substring(s)}function G(t,n){let e="";for(let o=0;o<t.length;o+=1)e+=n(t[o],o);return e}const I={$$render:()=>""};function M(t,n){if(!t||!t.$$render)throw n==="svelte:component"&&(n+=" this={...}"),new Error(`<${n}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`);return t}let l;function N(t){function n(e,o,r,s,c){const i=a,b={on_destroy:l,context:new Map(c||(i?i.$$.context:[])),on_mount:[],before_update:[],after_update:[],callbacks:g()};d({$$:b});const h=t(e,o,r,s);return d(i),h}return{render:(e={},{$$slots:o={},context:r=new Map}={})=>{l=[];const s={title:"",head:"",css:new Set},c=n(s,e,{},o,r);return y(l),{html:c,css:{code:Array.from(s.css).map(i=>i.code).join(`
`),map:null},head:s.title+s.head}},$$render:n}}function X(t,n,e){if(n==null||e&&!n)return"";const o=e&&n===!0?"":`="${k(n,!0)}"`;return` ${t}${o}`}function S(t){return Object.keys(t).filter(n=>t[n]).map(n=>`${n}: ${t[n]};`).join(" ")}function Y(t){const n=S(t);return n?` style="${n}"`:""}export{E as a,C as b,N as c,D as d,k as e,G as f,O as g,Y as h,F as i,X as j,q as k,R as l,I as m,p as n,A as o,T as p,z as q,P as s,M as v};
